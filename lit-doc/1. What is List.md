# What is Lit?

Lit is a simple library for building fast, lightweight web components.

At Lit's core is a boilerplate-killing component base class that provides reactive state, scoped styles, and a declarative template system that's tiny, fast and expressive.

## What can I build with Lit?

You can build just about any kind of web UI with Lit!

The first thing to know about Lit is that **every Lit component is a standard [web component](https://developer.mozilla.org/en-US/docs/Web/Web_Components)**. Web components have the superpower of interoperability: natively supported by browsers, web components can be used in any HTML environment, with any framework or none at all.

This makes Lit an ideal choice for developing **shareable components or design systems**. Lit components can be used across multiple apps and sites, even if those apps and sites are built on a variety of front-end stacks. Site developers using Lit components don’t need to write or even see any Lit code; they can just use the components the same way they do built-in HTML elements.

Lit is also perfect for **progressively enhancing basic HTML sites**. Browsers will recognize Lit components in your markup and initialize them automatically–whether your site is handcrafted, managed via a CMS, built with a server-side framework, or generated by a tool like Jekyll or eleventy.

Of course, you can also build **highly interactive, feature-rich apps** out of Lit components, just as you would with a framework like React or Vue. Lit’s capabilities and developer experience are comparable to these popular alternatives, but Lit minimizes lock-in, maximizes flexibility and promotes maintainability by embracing the browser’s native component model.

When you build an app with Lit, it’s easy to sprinkle in “vanilla” web components, or web components built with other libraries. You can even update to a major new version of Lit–or migrate to another library–one component at a time, without disrupting product development.

## What is it like to develop with Lit?

If you’ve done any modern, component-based web development, you should feel right at home with Lit. Even if you haven’t developed with components before, we think you’ll find Lit to be very approachable.

Each Lit component is a self-contained unit of UI, assembled from smaller building blocks: standard HTML elements and other web components. In turn, each Lit component is itself a building block that can be used–within an HTML document, another web component, or a framework component–to build larger and more complex interfaces.

Here’s a small but non-trivial component (a countdown timer) that illustrates what Lit code looks like and highlights several key features:

```typescript
import {LitElement, html, css} from 'lit';
import {customElement, property, state} from 'lit/decorators.js';
/* playground-fold */
import {play, pause, replay} from './icons.js';
/* playground-fold-end */

@customElement("my-timer")
export class MyTimer extends LitElement {
  static styles = css`/* playground-fold */

    :host {
      display: inline-block;
      min-width: 4em;
      text-align: center;
      padding: 0.2em;
      margin: 0.2em 0.1em;
    }
    footer {
      user-select: none;
      font-size: 0.6em;
    }
    /* playground-fold-end */`;

  @property() duration = 60;
  @state() private end: number | null = null;
  @state() private remaining = 0;

  render() {
    const {remaining, running} = this;
    const min = Math.floor(remaining / 60000);
    const sec = pad(min, Math.floor(remaining / 1000 % 60));
    const hun = pad(true, Math.floor(remaining % 1000 / 10));
    return html`
      ${min ? `${min}:${sec}` : `${sec}.${hun}`}
      <footer>
        ${remaining === 0 ? '' : running ?
          html`<span @click=${this.pause}>${pause}</span>` :
          html`<span @click=${this.start}>${play}</span>`}
        <span @click=${this.reset}>${replay}</span>
      </footer>
    `;
  }
  /* playground-fold */

  start() {
    this.end = Date.now() + this.remaining;
    this.tick();
  }

  pause() {
    this.end = null;
  }

  reset() {
    const running = this.running;
    this.remaining = this.duration * 1000;
    this.end = running ? Date.now() + this.remaining : null;
  }

  tick() {
    if (this.running) {
      this.remaining = Math.max(0, this.end! - Date.now());
      requestAnimationFrame(() => this.tick());
    }
  }

  get running() {
    return this.end && this.remaining;
  }

  connectedCallback() {
    super.connectedCallback();
    this.reset();
  }/* playground-fold-end */

}
/* playground-fold */

function pad(pad: unknown, val: number) {
  return pad ? String(val).padStart(2, '0') : val;
}/* playground-fold-end */

```

index.html

```html
<!doctype html>
<head><!-- playground-fold -->
  <link rel="preconnect" href="https://fonts.gstatic.com">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@1,800&display=swap" rel="stylesheet">
  <script type="module" src="./my-timer.js"></script>
  <style>
    body {
      font-family: 'JetBrains Mono', monospace;
      font-size: 36px;
    }
  </style>
  <!-- playground-fold-end -->
</head>
<body>
  <my-timer duration="7"></my-timer>
  <my-timer duration="60"></my-timer>
  <my-timer duration="300"></my-timer>
</body>
```

icons.ts

```typescript
import {html} from 'lit';

export const replay = html`<svg xmlns="http://www.w3.org/2000/svg" enable-background="new 0 0 24 24" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><title>Replay</title><g><rect fill="none" height="24" width="24"/><rect fill="none" height="24" width="24"/><rect fill="none" height="24" width="24"/></g><g><g/><path d="M12,5V1L7,6l5,5V7c3.31,0,6,2.69,6,6s-2.69,6-6,6s-6-2.69-6-6H4c0,4.42,3.58,8,8,8s8-3.58,8-8S16.42,5,12,5z"/></g></svg>`;
export const pause = html`<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><title>Pause</title><path d="M0 0h24v24H0V0z" fill="none"/><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>`;
export const play = html`<svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px" fill="#000000"><title>Play</title><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10 8.64L15.27 12 10 15.36V8.64M8 5v14l11-7L8 5z"/></svg>`;

```

Some things to note:

- Lit's main feature is the `LitElement` base class, a convenient and versatile extension of the native `HTMLElement`. You extend from it to define your own components.
- Lit’s [expressive, declarative templates](https://lit.dev/docs/templates/overview/) (utilizing JavaScript tagged template literals) make it easy to describe how a component should be rendered.
- [Reactive properties](https://lit.dev/docs/components/properties/) represent a component’s public API and/or internal state; your component automatically re-renders whenever a reactive property changes.
- [Styles](https://lit.dev/docs/components/styles) are scoped by default, keeping your CSS selectors simple and ensuring that your component’s styling won’t pollute (or be polluted by) the surrounding context.
- Lit works great in vanilla JavaScript, or you can use TypeScript for even better ergonomics by using decorators and type declarations.

Lit doesn’t require compilation or building during development, so it can be used virtually tool-free if you prefer. First-class [IDE support](https://lit.dev/docs/tools/development/#ide-plugins) (code-completion, linting, etc.) and [tooling for production](https://lit.dev/docs/tools/production/) (localization, template minification, etc.) are readily available.

## Why should I choose Lit?

[Permalink to “Why should I choose Lit?”#](https://lit.dev/docs/#why-should-i-choose-lit)

As we’ve already noted, Lit is a great choice for building all sorts of web UI, pairing the interop-based advantages of web components with a modern, ergonomic developer experience.

Lit is also:

- **Simple.** Building on top of the Web Components standards, Lit adds just what you need to be happy and productive: reactivity, declarative templates and a handful of thoughtful features to reduce boilerplate and make your job easier.
- **Fast.** Updates are fast, because Lit keeps track of your UI’s dynamic parts and updates only those when the underlying state changes–no need to rebuild a whole virtual tree and diff it with the current state of the DOM.
- **Lightweight.** Weighing in at around 5 KB (minified and compressed), Lit helps keep bundle sizes small and loading times short.

The team behind Lit has been involved with Web Components from day one. We help Google maintain tens of thousands of components, offer a comprehensive set of web components polyfills, and engage deeply in standards and community work.

Every Lit feature is carefully designed with web platform evolution in mind; we aim to help you take full advantage of what the platform provides today while writing code that is ready to benefit from future enhancements.

## Next steps

[Permalink to “Next steps”#](https://lit.dev/docs/#next-steps)

- [Getting started](https://lit.dev/docs/getting-started/): Get set up to start developing with Lit.
- [Components](https://lit.dev/docs/components/overview/): Learn about the Lit component model.
- [Templates](https://lit.dev/docs/templates/overview/): Write templates with lit-html syntax.
- [Code organization](https://lit.dev/docs/composition/overview/): Write reusable, maintainable code.

